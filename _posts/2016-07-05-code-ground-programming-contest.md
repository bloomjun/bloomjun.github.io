---
layout: article
categories: cpp
title: "[Code Ground] 프로그래밍 경진대회"
tags: [Code Ground]
comments: true
---

## 문제요약
- 프로그래밍 대회는 여러 라운드로 진행된다.
- 모든 라운드의 참가자의 수는 N명이다.
- 각 라운드 마다 1등은 N점,  2등은 N-1점, ···, 꼴등은 1점을 얻는다.
- 각 라운드 마다 동점자는 존재하지 않는다.
- 각 라운드 마다 얻은 점수의 총합을 종합점수라고 하고, 이 점수가 가장 높은 사람이 우승하게 된다.
- 마지막 라운드 직전까지의 종합점수가 주어졌을 때, 우승할 수 있는 사람의 수를 출력하라.
- 공동 우승자가 존재할 수 있다.

## 입력 조건
- 1 <= T <= 5
- 1 <= N <= 300,000
- 0 <= 최종 라운드 전까지 종합점수 <= 2,000,000

## 출력 조건
- 최종 우승할 수 있는 사람의 수를 출력

## 문제 해결 계획
### CASE1 : 완전탐색
1. 마지막 라운드전까지 N개의 종합점수를 입력받고, 배열 혹은 벡터에 저장한다.
2. 우승가능 여부를 저장할 크기가 N인 논리 자료형 배열을 선언하고 false 값으로 초기화 한다.
3. 반복문으로 구현하려면 N중 반복문으로 구현해야 하기 때문에 재귀를 통하여 우승할 수 있는 경우를 찾아야한다.
4. 우승할 수 있는 참가자를 찾는 다면 우승가능 여부를 저장하는 배열을 true 값으로 변환시키고, 해당 재귀는 반환한다.
5. 첫 번째 원소부터 마지막 원소까지 모두 우승가능 여부를 확인한다.
6. 마지막으로 우승가능 여부를 저장한 배열의 true 값이 있을 경우만 카운트하여 결과를 출력한다.

### CASE2: 정렬을 이용하는 방법
1. 마지막 라운드전까지 N개의 종합점수를 입력받고, 배열 혹은 벡터에 저장하고, 오름차순으로 정렬한다.
2. 오름차순 정렬한 값에 차례로 1등, 2등, ..., 꼴등의 순위를 매기면서 종합점수의 최대값을 찾는다.
3. 각각의 참가자를 1등이라고 가정하고 과정2에서 구한 최대값과 비교하여 우승 여부를 판별하고 우승할 수 있는 참가자들의 수를 카운트한다.
4. 우승할 수 있는 참가자들의 수를 출력한다.


### 검증
#### CASE1 : 문제를 해결할 수 없다.
```
완전 탐색의 경우 N!의 경우의 수를 비교해야 우승할 수 있는 참가자를 찾을 수 있다.
우승할 수 있는 참가자를 세는 경우 N번의 연산이 필요하다.
따라서 O(N!+N)이고,  최악의 경우 테스트 케이스마다 (300,000!+300,000) 번의 연산을 해야한다.
1초에 대략 1억번의 연산을 수행할 수 있으므로, 이 방법으로는 문제를 해결할 수 없다.
```
#### CASE2: 문제를 해결할 수 있다.
```
입력 받은 종합점수를 오름차순으로 정렬을 하고, 마지막 라운드는 점수가 가장 낮은 사람을 1등 부터  시작하여 순위를 매긴다.
이는 가장 마지막 라운드 이전의 상황에서 점수가 가장 낮은 참가자가 1등을 할 수 있는 가장 좋은 경우이다.
그리고 위 처럼 마지막 라운드를 진행한다면, 1등을 할 수 있는 점수 중 가장 낮은 점수를 찾을 수 있다.
따라서 마지막 라운드 이전의 각각의 참가자들이 1등을 할 수 있는 경우는 1등을 할 수 있는 가장 낮은 점수보다 크거나 같으면 된다.
N개의 원소 정렬에 대한 시간복잡도: O(Nlog2N)
최대값을 찾는 것에 대한 시간복잡도: O(N)
우승할 수 있는 참가자를 찾는 것에 대한 시간복잡도: O(N)
알고리즘의 시간복잡도: O(N + Nlog2N)
최악의 경우 대략  테스트 케이스 마다 대략 6,000,000번 연산이 필요하다.
1초에 대략 1억번의 연산을 수행할 수 있으므로, 이 방법으로는 문제를 해결할 수 있다.
```

## 문제 풀이
<script src="https://gist.github.com/junne47/f7cd5db1b636e72da7c3e6de24b1b912.js"></script>
